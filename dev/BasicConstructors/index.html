<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · NetworkDynamics</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NetworkDynamics</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">General</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#VertexFunctions-1"><span>VertexFunctions</span></a></li><li><a class="tocitem" href="#EdgeFunctions-1"><span>EdgeFunctions</span></a></li><li><a class="tocitem" href="#Constructor-1"><span>Constructor</span></a></li></ul></li><li><a class="tocitem" href="../Library/">Library</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../getting_started_with_network_dynamics/">Getting started</a></li><li><a class="tocitem" href="../directed_and_weighted_graphs/">Directed and weighted graphs</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/FHell/NetworkDynamics.jl/blob/master/docs/src/BasicConstructors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h1><p>The key constructor <a href="../Library/#NetworkDynamics.network_dynamics"><code>network_dynamics</code></a> assembles the dynamics of the whole network from functions for the single vertices and edges of the graph <code>g</code>. Since the equations describing the local dynamics may differ strongly from each other, the types <code>VertexFunction</code> and <code>EdgeFunction</code> are introduced. They provide a unifying interface between different classes of nodes and edges. Both have several subtypes that account for the different classes of equations that may represent the local dynamics. At the moment algebraic (static) equations and ordinary differential equations (ODEs) are supported:</p><pre><code class="language-julia"># VertexFunctions
StaticVertex(vertexfunction!, dimension, symbol)
ODEVertex(vertexfunction!, dimension, mass_matrix, symbol)

# EdgeFunctions
StaticEdge(edgefunction!, dimension, symbol)
ODEEdge(edgefunction!, dimension, mass_matrix, symbol)</code></pre><h1 id="VertexFunctions-1"><a class="docs-heading-anchor" href="#VertexFunctions-1">VertexFunctions</a><a class="docs-heading-anchor-permalink" href="#VertexFunctions-1" title="Permalink"></a></h1><p>Given a set of (algebraic or differential) equations describing a node or an edge the first step is to turn them into a <strong>mutating</strong> function <code>vertexfunction!</code>. Depending on the class of the function <code>vertexfunction!</code>, the constructors <code>StaticVertex</code> or <code>ODEVertex</code> are called in order to turn <code>vertexfunction!</code> into a <code>VertexFunction</code> object compatible with <a href="../Library/#NetworkDynamics.network_dynamics"><code>network_dynamics</code></a>.</p><p>Since in general the state of a vertex depends on the vertex value itself as well as on the in- and outgoing edges, the function <code>vertexfunction!</code> has to respect one of the following calling syntaxes.</p><pre><code class="language-julia"># For static nodes
function vertexfunction!(v, e_s, e_d, p, t) end
# For dynamic nodes
function vertexfunction!(dv, v, e_s, e_d, p, t) end</code></pre><p>Here <code>dv</code>, <code>v</code>, <code>p</code> and <code>t</code> are the usual ODE arguments, while <code>e_s</code> and <code>e_d</code> are arrays containing the edges for which the described vertex is the source or the destination respectively. The typical case of diffusive coupling on a directed graph could be described as</p><pre><code class="language-julia">function vertex!(dv, v, e_s, e_d, p, t)
    dv .= 0.
    for e in e_s
        dv .-= e
    end
    for e in e_d
        dv .+= e
    end
    nothing
end</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The arguments <code>e_s</code> and <code>e_d</code> are <strong>obligatory</strong> even if the graph is undirected and no distinction between source and destination can be made. This is necessary since <a href="https://github.com/JuliaGraphs/LightGraphs.jl">LightGraphs.jl</a> implements an undirected graph in the same way as a directed graphs, but ignores the directionality information. Therefore some care has to be taken when dealing with assymetric coupling terms. A detailed example can be found  in the <a href="../getting_started_with_network_dynamics/#getting_started-1">Getting started</a> tutorial.</p></div></div><h3 id="[StaticVertex](@ref)-1"><a class="docs-heading-anchor" href="#[StaticVertex](@ref)-1"><a href="../Library/#NetworkDynamics.NDFunctions.StaticVertex"><code>StaticVertex</code></a></a><a class="docs-heading-anchor-permalink" href="#[StaticVertex](@ref)-1" title="Permalink"></a></h3><p>If a vertex is described by an algebraic equation  <code>vertexfunction!(v, e_s, e_d, p, t)</code>, i.e. <code>dv = 0</code> the <code>VertexFunction</code> is constructed as</p><pre><code class="language-julia">StaticVertex(vertexfunction!, dim, sym)</code></pre><p>Here, <strong>dim</strong> is the number of independent variables in the vertex equations and <strong>sym</strong> is an array of symbols for these variables. For example, if a node models a constant input <span>$I = p$</span>, then <code>dim = 1</code> and <code>sym = [:I]</code>. For more details on the use of symbols, check out the <a href="../getting_started_with_network_dynamics/#getting_started-1">Getting started</a> tutorial and the Julia <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">documentation</a>. The use of symbols makes it easier to later fish out the interesting variables one wants to look at.</p><h3 id="[ODEVertex](@ref)-1"><a class="docs-heading-anchor" href="#[ODEVertex](@ref)-1"><a href="../Library/#NetworkDynamics.NDFunctions.ODEVertex"><code>ODEVertex</code></a></a><a class="docs-heading-anchor-permalink" href="#[ODEVertex](@ref)-1" title="Permalink"></a></h3><p>If a vertex has local dynamics <code>vertexfunction!(dv, v, e_s, e_d, p, t)</code> described by an ODE the <code>VertexFunction</code> is contructed as</p><pre><code class="language-julia">ODEVertex(vertexfunction!, dim, mass_matrix, sym)</code></pre><p>As above, <strong>dim</strong> is the number of independent variables in the vertex equations and <strong>sym</strong> corresponds to the symbols of these variables.</p><p><strong>mass_matrix</strong> is an optional argument that defaults to the identity matrix <code>I</code>. If a mass matrix M is given the local system <code>M * dv = vertexfunction!</code> will be solved. <code>network_dynamics</code> assembles all local mass matrices into one global mass matrix that can be passed to a differential equation solver like <code>Rodas4</code>.</p><p>One may also call ODEVertex with keyword arguments, omitting optional arguments:</p><pre><code class="language-julia">ODEVertex(f! = vertexfunction!, dim = dim)</code></pre><p>The function then defaults to using the identity as mass matrix and <code>[:v for i in 1:dimension]</code> as symbols.</p><h2 id="EdgeFunctions-1"><a class="docs-heading-anchor" href="#EdgeFunctions-1">EdgeFunctions</a><a class="docs-heading-anchor-permalink" href="#EdgeFunctions-1" title="Permalink"></a></h2><p>Similar to the case of vertices, an edge is described by <strong>mutating</strong> function <code>edgefunction!</code>. At the moment the constructors <code>StaticEdge</code> and <code>ODEEdge</code> are available. <code>edgefunction!</code> has to respect one of the following syntaxes:</p><pre><code class="language-julia"># For static edges
function edgefunction!(e, v_s, v_d, p, t) end
# For dynamics edges
function edgefunction!(de, e, v_s, v_d, p, t) end</code></pre><p>Just like above, <code>de</code>, <code>e</code>, <code>p</code> and <code>t</code> are the usual ODE arguments, while <code>v_s</code> and <code>v_d</code> are the source and destination vertices respectively.</p><h3 id="[StaticEdge](@ref)-1"><a class="docs-heading-anchor" href="#[StaticEdge](@ref)-1"><a href="../Library/#NetworkDynamics.NDFunctions.StaticEdge"><code>StaticEdge</code></a></a><a class="docs-heading-anchor-permalink" href="#[StaticEdge](@ref)-1" title="Permalink"></a></h3><p>Static here means, that the edge value described by <code>edgefunction!</code> only depends on the values of the vertices the edge connects to and that no derivative of the edge&#39;s internal state is involved. One very simple and natural example is a diffusive edge:</p><pre><code class="language-julia">edgefunction! = (e, v_s, v_d, p, t) -&gt; e .= v_s .- v_d</code></pre><p>In this case the <code>EdgeFunction</code> is constructed by</p><pre><code class="language-julia">StaticEdge(edgefunction!, dim, sym)</code></pre><p>The keywords are the same as for the vertices.</p><h3 id="[ODEEdge](@ref)-1"><a class="docs-heading-anchor" href="#[ODEEdge](@ref)-1"><a href="../Library/#NetworkDynamics.NDFunctions.ODEEdge"><code>ODEEdge</code></a></a><a class="docs-heading-anchor-permalink" href="#[ODEEdge](@ref)-1" title="Permalink"></a></h3><p>For problems where <code>edgefunction!</code> describes the differential of an edge value, we use the <code>ODEEdge</code> function. An example for such a system is given by:</p><pre><code class="language-julia">edgefunction! = (de, e, v_s, v_d, p, t) -&gt; de .= 1000 * (v_s .- v_d .- e)</code></pre><p>The <code>EdgeFunction</code> object is constructed as</p><pre><code class="language-julia">ODEEdge(edgefunction!, dim, mass_matrix, sym)</code></pre><p>The keywords are the same as for the vertices. For <code>ODEEdge</code> the same simplified construction rules apply when keyword arguments are used.</p><pre><code class="language-julia">ODEEdge(f! = edgefunction!, dim = n)</code></pre><p>In this case the function defaults to using the identity as mass matrix and <code>[:e for in 1:dimension]</code> as symbols.</p><h2 id="Constructor-1"><a class="docs-heading-anchor" href="#Constructor-1">Constructor</a><a class="docs-heading-anchor-permalink" href="#Constructor-1" title="Permalink"></a></h2><p>The key constructor is the function <a href="../Library/#NetworkDynamics.network_dynamics"><code>network_dynamics</code></a> that takes in two arrays of <code>EdgeFunctions</code> and <code>VertexFunctions</code> describing the local dynamics on the edges and nodes of a graph <code>g</code>, given as a <a href="https://github.com/JuliaGraphs/LightGraphs.jl">LightGraphs.jl</a> object. It returns a composite function compatible with the <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl">DifferentialEquations.jl</a> calling syntax.</p><pre><code class="language-julia">nd = network_dynamics(vertices!::Array{VertexFunction},
                      edges!::Array{EdgeFunction}, g)
nd(dx, x, p, t)</code></pre><h3 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example</a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h3><p>Let&#39;s look at an example. First we define our graph as well as the differential systems connected to its vertices and edges:</p><pre><code class="language-julia">using NetworkDynamics, LightGraphs

g = erdos_renyi(10, 25) # random graph with 10 vertices and 25 edges

function vertexfunction!(dv, v, e_s, e_d, p, t)
  dv .= 0
  for e in e_s
    dv .-= e
  end
  for e in e_d
    dv .+= e
  end
end

function edgefunction!(de, e, v_s, v_d, p, t)
     de .= 1000 .*(v_s .- v_d .- e)
     nothing
end

vertex = ODEVertex(f! = vertexfunction!, dim = 1)
vertexarr = [vertex for v in vertices(g)]

edge = ODEEdge(f! = edgefunction!, dim = 1)
edgearr = [edge for e in edges(g)]

nd = network_dynamics(vertexarr, edgearr, g)</code></pre><p>Now we have an <code>ODEFunction nd</code> that can be solved with the tools provided by <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl">DifferentialEquations.jl</a>.</p><p>For more details check out the Tutorials section.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« General</a><a class="docs-footer-nextpage" href="../Library/">Library »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 17 February 2020 16:26">Monday 17 February 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
